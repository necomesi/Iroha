<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Iroha.KeyEquiv</title>
<link rel="stylesheet" href="../assets/css/base.css">
<script src="../assets/js/jquery.js"></script>
<script src="../project/Iroha/iroha/iroha.js"></script>
<script src="../project/Iroha/keyEquiv/iroha.keyEquiv.js"></script>
<script src="_docfiles/sample.js"></script>
</head>
<body>

<h1>Iroha.KeyEquiv</h1>

<ul id="to-index">
	<li><a href="../index.html">Necomesi JavaScript Library (Iroha)</a></li>
</ul>

<h2 id="overview">概要</h2>

<p>キーボード操作による処理呼び出しを簡単に行うための機構を提供します。</p>

<h2 id="coverage">動作確認ブラウザ</h2>

<p>(fixme)</p>

<h2 id="deployment">実装ファイル配置</h2>

<p>(fixme)</p>

<h3>HTML への組み込み</h3>

<p>(fixme)</p>

<h2 id="autosetup">AutoSetup</h2>

<p>(fixme)</p>

<h2 id="examples">動作例</h2>

<p><kbd>Shift</kbd> キーを押しながら <kbd>A</kbd> キーを押してみてください。</p>

<h2 id="keydefinitions">キーコンビネーション指示子</h2>

<h3>概要</h3>

<p>「 <kbd>Shift</kbd> キーを押しながら <kbd>A</kbd> キーを押す」というようなキーコンビネーションの表記法。あるいはこの表記法を用いた文字列のこと。</p>

<p>この表記法は、同時に押すキーの組み合わせを記述するものであり、 「<kbd>Q</kbd> , <kbd>W</kbd> , <kbd>E</kbd> , <kbd>R</kbd> , <kbd>T</kbd> , <kbd>Y</kbd> の順でキーを押していく」というような事は記述できません。そもそも <code>Iroha.KeyEquiv</code> 自体、そのような逐次キー押下を取り扱う実装が（現時点では）ありません。</p>

<h3>記述例</h3>

<p>キーコンビネーション指示子中のそれぞれの文字（キー表現記号）は、それぞれが任意のキーに対応します。</p>

<ul>
	<li><code>"A"</code> は、「 <kbd>A</kbd> キーを押す」ことを表します。</li>
	<li><code>"$"</code> は、「 <kbd>Shift</kbd> キーを押す」ことを表します。</li>
	<li><code>"$A"</code> は、「 <kbd>Shift</kbd> キーを押しながら <kbd>A</kbd> キーを押す」ことを表します。</li>
	<li><code>"$%A"</code> は、「 <kbd>Shift</kbd> キー・<kbd>Ctrl</kbd> キーを押しながら <kbd>A</kbd> キーを押す」ことを表します。</li>
	<li>キー表現記号の出現順に特にルールはありません。つまり、 <code>"$%A"</code> と <code>"A%$"</code> は同じものとして扱われます。</li>
	<li>同じキー表現記号を複数回含んでいる場合は、それぞれがひとつに集約されて扱われます。つまり、 <code>"$$$%A%AA$"</code> は <code>"$%A"</code> と同じものとして扱われます。</li>
</ul>

<h3 id="normalize">正規化</h3>

<p><code>Iroha.KeyEquiv</code> は、与えられたキーコンビネーション指示子を以下のルールで正規化し、取り扱っています。</p>

<ol>
	<li>キーコンビネーション指示子中の重複する文字をひとつに集約</li>
	<li>キーコンビネーション指示子中の文字をソート</li>
</ol>

<h3>キー表現記号</h3>

<p>キーコンビネーション指示子中で使える文字（キー表現記号）は、以下の 4 種類に大別されます。</p>

<dl>
	<dt>アルファベットキー</dt>
	<dd>
		<table summary="キー表記法（アルファベットキー）">
		<thead>
		<tr><th>キー表現記号</th><th>キー</th><th>(Event.keyCode)</th></tr>
		</thead>
		<tbody>
		<tr><td><code>A</code></td><td><kbd>A</kbd></td><td>65</td></tr>
		<tr><td><code>B</code></td><td><kbd>B</kbd></td><td>66</td></tr>
		<tr><td><code>C</code></td><td><kbd>C</kbd></td><td>67</td></tr>
		<tr><td>:</td><td>:</td><td>:</td></tr>
		<tr><td><code>Z</code></td><td><kbd>Z</kbd></td><td>90</td></tr>
		</tbody>
		</table>
		<p>大文字小文字の区別はありません。</p>
	</dd>
	<dt>半角数字キー</dt>
	<dd>
		<table summary="キー表記法（数字キー）">
		<thead>
		<tr><th>キー表現記号</th><th>キー</th><th>(Event.keyCode)</th></tr>
		</thead>
		<tbody>
		<tr><td><code>0</code></td><td><kbd>0</kbd></td><td>48</td></tr>
		<tr><td><code>1</code></td><td><kbd>1</kbd></td><td>49</td></tr>
		<tr><td><code>2</code></td><td><kbd>2</kbd></td><td>50</td></tr>
		<tr><td>:</td><td>:</td><td>:</td></tr>
		<tr><td><code>9</code></td><td><kbd>9</kbd></td><td>57</td></tr>
		</tbody>
		</table>
		<p>通常の数字キーと、テンキーパッド部の数字キーの区別はありません。</p>
	</dd>
	<dt>特殊キー</dt>
	<dd>
		<table summary="キー表記法（特殊キー）">
		<thead>
		<tr><th>キー表現記号</th><th>キー</th><th>(Event.keyCode)</th></tr>
		</thead>
		<tbody>
		<tr><td><code>|</code></td><td><kbd>Tab</kbd></td><td>9</td></tr>
		<tr><td><code>#</code></td><td><kbd>Enter</kbd></td><td>13</td></tr>
		<tr><td><code>!</code></td><td><kbd>Esc</kbd></td><td>27</td></tr>
		<tr><td><code>&lt;</code></td><td><kbd>←</kbd></td><td>37</td></tr>
		<tr><td><code>{</code></td><td><kbd>↑</kbd></td><td>38</td></tr>
		<tr><td><code>&gt;</code></td><td><kbd>→</kbd></td><td>39</td></tr>
		<tr><td><code>}</code></td><td><kbd>↓</kbd></td><td>40</td></tr>
		</tbody>
		</table>
	</dd>
	<dt>修飾キー</dt>
	<dd>
		<table summary="キー表記法（修飾キー）">
		<thead>
		<tr><th>キー表現記号</th><th>キー</th><th>(Event.keyCode)</th></tr>
		</thead>
		<tbody>
		<tr><td><code>$</code></td><td><kbd>Shift</kbd></td><td>16</td></tr>
		<tr><td><code>%</code></td><td><kbd>Ctrl</kbd></td><td>17</td></tr>
		<tr><td><code>~</code></td><td><kbd>Alt</kbd> , <kbd>Option</kbd></td><td>18</td></tr>
		<tr><td><code>&amp;</code></td><td><kbd>Windows</kbd> , <kbd>Command</kbd></td><td>(ブラウザ毎に異なる)</td></tr>
		</tbody>
		</table>
	</dd>
</dl>

<h3>注意事項</h3>

<ul>
	<li><em>ブラウザや OS 本来のキーボード操作を妨げないキーボードコンビネーションを設定するよう、注意してください。</em></li>
	<li>加えて、ブラウザ個別の制限事項を考慮すると、<em>修飾キーとして安全に利用できそうなのは <kbd>Shift</kbd> キーのみかもしれません。</em></li>
	<li><em>「修飾キー」のみ、他のキーと同時に押されたことを判別できます。</em>例えば、「 <kbd>Shift</kbd> キーと <kbd>A</kbd> キーが同時に押された」事は判別できますが、「 <kbd>A</kbd> と <kbd>B</kbd> が同時に押された」事は判別できません。</li>
	<li>ここに挙げた以外のキー（主に記号キーなど）については、サポートされません。動くかもしれませんが、ユーザの使っているキーボードの配列によっては、修飾キーなしには押せないものもあるので、推奨しません。</li>
</ul>

<h4>ブラウザ個別の制限事項</h4>

<dl>
	<dt>WinIE</dt>
	<dd>
		<p><kbd>Windows</kbd>キー の押下を判別することはできません。</p>
	</dd>
	<dt>MacIE</dt>
	<dd>
		<p><kbd>Command</kbd> キーの押下を判別することはできません。</p>
		<p><kbd>Ctrl</kbd> キーの押下判別（の反応）が鈍く、さらに、単独で押下された時しか判別できません。（ MacIE の GUI に由来する制限）</p>
	</dd>
	<dt>Gecko 系</dt>
	<dd>
		<p><kbd>Windows</kbd> キー (Windows) 、 <kbd>Command</kbd> キー (Mac) の押下を判別することはできません。</p>
	</dd>
	<dt>Safari </dt>
	<dd>
		<p>修飾キーのみの押下を判別することはできません。つまり、修飾キー以外のキーとの組みあわせた時しか判別できません。</p>
	</dd>
	<dt>Opera</dt>
	<dd>
		<p>修飾キーのみの押下を判別することはできません。つまり、修飾キー以外のキーとの組みあわせた時しか判別できません。</p>
		<p><kbd>Shift</kbd> キー以外の修飾キーは、他ブラウザと比較しても珍妙な取り扱いがされてしまっており、 <code>Iroha.KeyEquiv</code> はそれを吸収しきれません。使用しないほうが良いでしょう。</p>
	</dd>
</dl>

<p><strong>(fixme) 2009年6月現在、この項の内容は古くなっています。現在は状況が変わっている可能性が大きいです。</strong></p>

<h2 id="definitions">コンストラクタ・メソッド解説</h2>

<h3 id="Iroha.KeyEquiv">Iroha.KeyEquiv<span class="info">(コンストラクタ)</span></h3>

<h4>クラスメソッド</h4>

<dl>
	<dt><code>Iroha.KeyEquiv.create(<dfn>node</dfn>)</code></dt>
	<dd>
		<table summary="引数について" class="parameters">
			<thead>
				<tr><th>引数名</th><th>型</th><th>説明</th><th>任意性</th></tr>
			</thead>
			<tbody>
				<tr><td><var>node</var></td><td><code>jQuery|Element|String</code></td><td>基底要素ノード（キーイベントを拾う要素）。またはそれを見つけるためのセレクタ文字列。無指定時は document.documentElement が与えられたものとみなす。<td>任意</td></tr></tr>
			</tbody>
		</table>
		<p>与えた要素ノードを基底要素ノードとする新規インスタンスを返す。ただしその要素ノードから作られた既存インスタンスがすでにあるなら、それを返す。</p>
		<p>返値： <code>Iroha.KeyEquiv</code> インスタンス</p>
	</dd>
	<dt><code>Iroha.KeyEquiv.getKeyAlias(<dfn>keyCode</dfn>)</code></dt>
	<dd>
		<table summary="引数について" class="parameters">
			<thead>
				<tr><th>引数名</th><th>型</th><th>説明</th><th>任意性</th></tr>
			</thead>
			<tbody>
				<tr><td><var>keyCode</var></td><td><code>Number</code></td><td>特殊キーのキーコード<td>必須</td></tr>
			</tbody>
		</table>
		<p>特殊キーの別名記号をキーコード指定により得る。該当するものがなければ空文字列 "" が返る。</p>
		<p>返値： <code>String</code> インスタンス</p>
	</dd>
</dl>

<h4>インスタンスメソッド</h4>

<dl>
	<dt><code>Iroha.KeyEquiv#addKey(<dfn>keys</dfn>, <dfn>func</dfn>, <dfn>aThisObject</dfn>)</code></dt>
	<dd>
		<table summary="引数について" class="parameters">
			<thead>
				<tr><th>引数名</th><th>型</th><th>説明</th><th>任意性</th></tr>
			</thead>
			<tbody>
				<tr><td><var>keys</var></td><td><code>String</code></td><td><a href="#keydefinitions">キーコンビネーション指示子</a>。</td><td>必須</td></tr>
				<tr><td><var>func</var></td><td><code><a href="#Iroha.KeyEquiv.callback">Iroha.KeyEquiv.callback</a></code></td><td><code>keys</code> に指定したキーコンビネーションが押されたときに呼び出される（コールバックされる）関数・メソッド</td><td>必須</td></tr>
				<tr><td><var>aThisObject</var></td><td><code>Object</code></td><td><code>func</code> 中で <code>"this"</code> キーワードが使用されている場合に、それが指し示すもの（オブジェクト）。<br>無指定時、 <code>"this"</code> は <code>"window"</code> を指し示すことになります。</td><td>任意</td></tr>
			</tbody>
		</table>
		<p>何らかの処理と、それを呼び出すためのキー操作（キーコンビネーション）の対応付けを行います。</p>
		<p>返値： <code>String</code><span class="info">（<a href="#normalize">正規化</a>済みのキーコンビネーション指示子）</span></p>
	</dd>

	<dt><code>Iroha.KeyEquiv.fireKey(<dfn>keys</dfn>)</code></dt>
	<dd>
		<table summary="引数について" class="parameters">
			<thead>
				<tr><th>引数名</th><th>型</th><th>説明</th><th>任意性</th></tr>
			</thead>
			<tbody>
				<tr><td><var>keys</var></td><td><code>String</code></td><td><a href="#keydefinitions">キーコンビネーション指示子</a>。</td><td>必須</td></tr>
			</tbody>
		</table>
		<p>任意のキーコンビネーションに対応付けられている処理の呼び出しを、実際のキーボード操作無しに行います。</p>
		<p>返値：なし</p>
	</dd>

	<dt><code>Iroha.KeyEquiv.getKeyName(<dfn>keys</dfn>)</code></dt>
	<dd>
		<table summary="引数について" class="parameters">
			<thead>
				<tr><th>引数名</th><th>型</th><th>説明</th><th>任意性</th></tr>
			</thead>
			<tbody>
				<tr><td><var>keys</var></td><td><code>String</code></td><td><a href="#keydefinitions">キーコンビネーション指示子</a>。</td><td>必須</td></tr>
			</tbody>
		</table>
		<p><a href="#keydefinitions">キーコンビネーション指示子</a>を与えると、それを人間にとって読みやすい形式へ変換したものが返ります。</p>
		<p>たとえば <code>Iroha.KeyEquiv.getKeyName("<em>$%A</em>")</code> とすると、<samp>["<em>Shift</em>", "<em>Ctrl</em>", "<em>A</em>"]</samp> が得られます。</p>
		<p>返値： <code>Array</code><span class="info">（人間にとって読みやすい形式のキー表記文字列からなる配列）</span></p>
	</dd>
</dl>

<h3 id="Iroha.KeyEquiv.callback">Iroha.KeyEquiv.callback<span class="info">(Fuction)</span></h3>

<p><code>Iroha.KeyEquiv.addKeyEquiv()</code> の引数 <code>func</code> に与える関数・メソッド（高階関数）のこと。実際は、引数 <code>func</code> には既存の関数オブジェクトを直接与えることになるので、これをどうこうして使う事は無い。単に（コールバックされた際に与えられる引数の）説明をするためだけの存在。</p>

<dl>
	<dt><code>Iroha.KeyEquiv.callback(<dfn>e</dfn>, <dfn>keys</dfn>, <dfn>keyNames</dfn>)</code></dt>
	<dd>
		<table summary="引数について" class="parameters">
			<thead>
				<tr><th>引数名</th><th>型</th><th>説明</th></tr>
			</thead>
			<tbody>
				<tr><td><var>e</var></td><td><code>Event</code></td><td>DOM Event オブジェクト<br>ただし <code>Iroha.KeyEquiv.fireKey()</code> によってコールバックされた時は <code>{}</code> です。</td></tr>
				<tr><td><var>keys</var></td><td><code>String</code></td><td><a href="#normalize">正規化</a>済みの<a href="#keydefinitions">キーコンビネーション指示子</a></td></tr>
				<tr><td><var>keyNames</var></td><td><code>Array</code></td><td>人間にとって読みやすい形式のキー表記文字列からなる配列</td></tr>
			</tbody>
		</table>
	</dd>
</dl>


<address>written by Koji Kasugai (<a href="mailto:kojika@necomesi.jp">kojika@necomesi.jp</a>) 2012-11-26</address>

</body>
</html>
